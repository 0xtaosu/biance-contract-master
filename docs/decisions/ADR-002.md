# ADR-002: Binance API Integration Architecture

**Date**: 2026-01-18
**Status**: Accepted

## Context

The project requires a REST API service to query Binance Futures contract prices for multiple tickers. This service needs to be performant, type-safe, and maintainable.

## Decision

### 1. Web Framework: Fastify

**Chosen**: Fastify 4.x
**Alternatives Considered**: Express, Koa, Hapi

**Rationale**:
- **Performance**: Fastify is one of the fastest Node.js frameworks (2-3x faster than Express)
- **TypeScript-first**: Built with TypeScript, providing excellent type inference and IDE support
- **Schema validation**: Built-in JSON schema validation reduces boilerplate
- **Plugin ecosystem**: Rich ecosystem with official plugins for common middleware (CORS, helmet, rate-limit)
- **Developer experience**: Excellent documentation and active community

Express was considered but lacks native TypeScript support and has lower performance. Fastify's architecture aligns better with our need for a modern, type-safe API.

### 2. Binance Client: Official SDK

**Chosen**: @binance/connector-typescript
**Alternatives Considered**: binance-api-node, node-binance-api, custom axios wrapper

**Rationale**:
- **Official support**: Maintained by Binance, ensuring compatibility with API changes
- **Type safety**: TypeScript-native with full type definitions
- **Up-to-date**: Receives timely updates when Binance API changes
- **Reliability**: Lower risk of breaking changes or abandoned maintenance

Third-party libraries were considered but carry risk of abandonment or delayed updates. Using the official SDK reduces maintenance burden.

### 3. Validation: Zod

**Chosen**: Zod
**Alternatives Considered**: Joi, Yup, class-validator

**Rationale**:
- **TypeScript-first**: Infers static types from schemas, reducing duplication
- **Composable**: Easy to build complex schemas from simpler ones
- **Runtime safety**: Validates data at runtime while maintaining type safety
- **Developer experience**: Clear error messages and intuitive API
- **Performance**: Lightweight with minimal overhead

Joi was considered but lacks TypeScript type inference. Zod provides both runtime validation and compile-time type safety without code duplication.

### 4. Environment Configuration: envalid

**Chosen**: envalid
**Alternatives Considered**: dotenv only, joi for env validation

**Rationale**:
- **Type-safe environment variables**: Validates and types environment variables
- **Built on dotenv**: Familiar API with added safety
- **Clear error messages**: Fails fast with helpful messages on missing/invalid env vars
- **Zero runtime overhead**: Validation happens once at startup

Using dotenv alone provides no type safety or validation. Envalid adds a thin validation layer that prevents runtime errors from misconfigured environments.

### 5. Logging: Winston

**Chosen**: Winston
**Alternatives Considered**: Pino, Bunyan, console.log

**Rationale**:
- **Flexible transports**: Can write to console, files, external services
- **Log levels**: Supports standard log levels (error, warn, info, debug)
- **Structured logging**: JSON format for easy parsing
- **Production-ready**: Battle-tested in production environments
- **Ecosystem**: Large ecosystem of transports and formatters

Pino is faster but Winston's flexibility and ecosystem make it better for this project's needs.

### 6. Testing: Vitest + nock

**Chosen**: Vitest for test runner, nock for HTTP mocking
**Alternatives Considered**: Jest + nock, Mocha + Chai

**Rationale**:
- **Vitest**: Native ES modules support, faster than Jest, compatible with Vite ecosystem
- **TypeScript support**: Zero-config TypeScript support
- **nock**: Industry-standard HTTP mocking library
- **Coverage**: Built-in coverage with v8 provider
- **Developer experience**: Fast test execution and watch mode

Jest was considered but Vitest offers better ES modules support and faster execution.

### 7. Data Fetching Strategy: On-Demand Queries

**Chosen**: On-demand queries without caching (initial version)
**Alternatives Considered**: Polling with in-memory cache, WebSocket subscriptions

**Rationale**:
- **Simplicity**: Start simple, add complexity only when needed
- **Fresh data**: Always return real-time data from Binance
- **No stale data**: Avoids cache invalidation complexity
- **Rate limit awareness**: Easier to monitor and manage API limits

**Future Consideration**: If performance becomes an issue or rate limits are hit, implement a short-lived cache (5-30 seconds) using node-cache or Redis.

### 8. API Design

**Endpoints**:
- `GET /api/v1/health` - Health check + Binance connectivity
- `GET /api/v1/prices/:symbol` - Single symbol price
- `POST /api/v1/prices/batch` - Multiple symbols (max 20)

**Rationale**:
- **Versioned API**: `/api/v1` prefix allows future API evolution
- **RESTful**: Follows REST conventions
- **Batch limit**: 20 symbols prevents abuse and reduces Binance API load
- **POST for batch**: Body allows flexible request structure and avoids URL length limits

### 9. Error Handling

**Approach**: Centralized error handler with consistent error format

**Error Response Format**:
```json
{
  "error": {
    "code": "INVALID_SYMBOL",
    "message": "Human-readable description",
    "details": {}
  }
}
```

**Rationale**:
- **Consistency**: All errors follow the same structure
- **Machine-readable codes**: Error codes enable programmatic handling
- **Details object**: Flexible structure for additional error context
- **HTTP status codes**: Proper 4xx and 5xx codes for different error types

## Consequences

### Positive
- Modern, performant tech stack with excellent TypeScript support
- Official Binance SDK reduces maintenance burden and API compatibility issues
- Type safety throughout the application reduces runtime errors
- Fast test execution with Vitest improves developer experience
- Simple architecture makes it easy to understand and modify

### Negative
- Fastify is less widely used than Express, potentially smaller talent pool
- On-demand queries may hit rate limits under high load (mitigated by future caching)
- Official Binance SDK may have breaking changes (low risk, but possible)

### Risks & Mitigations
- **Risk**: Binance API rate limits
  **Mitigation**: Implement request queuing, add caching if needed

- **Risk**: Binance API downtime
  **Mitigation**: Proper error handling, health check endpoint

- **Risk**: Large batch requests
  **Mitigation**: Hard limit of 20 symbols, validated at schema level

## Future Considerations
- Add Redis caching layer if rate limits become an issue
- Implement circuit breaker pattern for Binance API resilience
- Add request queuing with bottleneck library
- Consider WebSocket subscriptions for real-time price updates
- Add monitoring and alerting for API health

## Notes
This ADR can be revisited if performance or rate limit issues arise. The architecture is designed to support incremental improvements without requiring major rewrites.
